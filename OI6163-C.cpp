/**
 * 蓝桥2025省赛
 * 很逆天的解题思路:
 *  贪心+暴力枚举 - 检查配对次数
 *  暴力枚举所有可能组成6的配对数
 *  换句话说，其实这道题的目的就是凑出最多的6
 *  那为了最多，当然就是2个的优先，然后实在凑不出2个了再3个
 *  所以必须从5开始(这个肯定全部是2个)，再4紧随其后(4 1 1三个) 
 *  并且就算三个也得尽量消耗更多的小的数字，这样才能保证大的数字能凑成2个
 * 
 *  明确三点：
 *      1 6以上的就不配对了，配对了也是浪费数字
 *      2 越小的数字越不能留到后面，否则配对的希望越渺茫
 *      3 从5开始枚举到2和3，而不是从1开始枚举
 *          因为大数字留到后面不可能处理的，而小数据到后面还有能处理的可能性，只不过可能没那么大
 *  设计算法：
 *      5的话要尽量先跟小的配对(5先配对1再234，而不是4321)
 *          因为小的留到后面不好处理(例如1 1留到后面的话就不能配对了)，并且也不符合"凑出最多的6"的原则
 *      然后要保证5先配对完，否则5留到后面照样处理不了，这个数字就被浪费了
 *      并且5的话甚至还是2个数配对，还能找到更多的配对数量
 *      4的话同5
 */
#include <bits/stdc++.h>

using namespace std;

int nums[7] = {0};
int calcallNum(int n) {
    int c=0;
    while(n!=0) {
        int n1 = n%10;
        if(n1==6)c+=1;
        n /=10;
    }
    if(c>=6) return 6; 
    //nums[6]代表超过6的数字的数量
    return c;
}
int main() {
    int n;
    cin >> n;
    for(int i=0;i<n;i++) {
        int c;
        cin >> c;
        nums[calcallNum(c)] ++; 
        //每个数对应的6的个数相加，后续开始配对
    }
    //6以上的数不需要配对，配对了也是浪费数字
    //从5开始配对
    //5的话只能配对成2个数字的组，再多的话就浪费数字了
    int ptr = 1;
    while(nums[5] != 0) {//所以从5开始
        if(ptr > 6) break;//不能超过6
        if(ptr==5 && nums[5] == 1) break;
        //如果有两个5但是nums[5]不够减了就好去掉了
        // while(nums[ptr] != 0) {
        //     nums[5] -= 1;
        //     nums[ptr] -= 1;
        //     nums[6] +=1;
        // }
        //这样写不行，万一num[5]<0就炸了
        while(nums[ptr]==0) ptr++;
        nums[5]-=1;
        nums[ptr]-=1;
        nums[6]+=1;
        //同上
    }

    //先处理4 1 1的情况
    while(nums[4] != 0 && nums[1] > 1){
        nums[1] -= 2;//1 1
        nums[4] -= 1;//4
        nums[6] += 1;
    }

    //匹配4 2，4 3，4 4，4 5
    ptr = 2;
    while(nums[4] != 0) {
        if(ptr>5) break;
        if(ptr == 4 && nums[4] == 1) break;
        while(nums[ptr]==0) ptr++;
        nums[4]-=1;
        nums[ptr]-=1;
        nums[6]+=1;
    }

    //匹配3 2 1的情况
    while(nums[3] > 0 && nums[2] > 0 && nums[1] > 0) {
        nums[3] -= 1;
        nums[2] -= 1;
        nums[1] -= 1;
        nums[6] += 1;
    }

    //要是最后剩余3 2的话
    //nums[3]/2代表能凑出3的个数(纵然是小数也可以，因为求的总和)，3*2=6
    //nums[2]/3代表能凑出2的个数(同上)，2*3=6
    //两者加起来就是结果,但是注意通分，否则计算不准
    nums[6] += (nums[3]*3+nums[2]*2) / 6;
    cout << nums[6];
    return 0;
}